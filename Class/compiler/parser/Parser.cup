package compiler.parser;

import java_cup.runtime.*;
import compiler.scanner.Scanner;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.io.FileWriter;
import java.io.PrintWriter;

parser code {:
    private Scanner scanner;

    public Parser(Scanner scanner) {
        super();
        this.scanner = scanner;
    }

    public Symbol parse(String filename) throws Exception {
        try {
            scanner = new Scanner(new FileReader(filename));
            return this.parse();
        } catch (IOException e) {
            throw new RuntimeException("Error al leer el archivo: " + e.getMessage());
        }
    }

    @Override
    public Symbol scan() throws Exception {
        return scanner.next_token();
    }

    public void syntax_error(Symbol s) {
        String tokenName = sym.terminalNames[s.sym];
        String tokenValue = s.value == null ? "" : s.value.toString();
        String errorMessage = String.format(
            "Error Sintáctico en la Línea %d, Columna %d: Token '%s' no reconocido. Tipo: %s",
            s.right + 1, s.left + 1, tokenValue, tokenName
        );

        // Escribir en el archivo output.txt
        writeToFile(errorMessage);

        // Imprimir en la consola
        System.err.println(errorMessage);
    }

    private void writeToFile(String message) {
        try (PrintWriter out = new PrintWriter(new FileWriter("output.txt", true))) {
            out.println(message);
        } catch (IOException e) {
            System.err.println("Error al escribir en el archivo de salida: " + e.getMessage());
        }
    }
:};

/* Terminals (tokens returned by the scanner) */
terminal CLASS, INT, VOID, BOOLEAN, TRUE, FALSE, IF, RETURN, WHILE, FOR;
terminal ASSIGN, EQ, NOT_EQUALS, SEMI, LBRACE, RBRACE, LPAREN, RPAREN, PLUS, MINUS, TIMES, DIVIDE, COMMA;
terminal LESS_THAN, GREATER_THAN, LESS_THAN_EQUALS, GREATER_THAN_EQUALS, DOT, AND, OR, MOD, LBRACKET;
terminal String ID;
terminal Integer INT_LITERAL;
terminal Integer HEX_LITERAL;  
terminal String STRING_LITERAL;
terminal Character CHAR_LITERAL;


/* Non-terminals */
non terminal Object program, class_decl, method_decl, var_decl, type;
non terminal Object statement, expr, param_list, statement_list, arg_list;
non terminal Object class_body_member_list, class_body_member, field_decl, block;
non terminal Object block_item_list, block_item, decl, id_list, assignment;
non terminal Object arg_list_non_empty;

/* Precedences */
precedence left OR;
precedence left AND;
precedence left EQ, NOT_EQUALS;
precedence left LESS_THAN, GREATER_THAN, LESS_THAN_EQUALS, GREATER_THAN_EQUALS;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence right ASSIGN;

/* The grammar rules */
start with program;

program ::= class_decl;

class_decl ::= CLASS ID:name LBRACE class_body_member_list RBRACE;

class_body_member_list ::= class_body_member_list class_body_member
                         | /* empty */;

class_body_member ::= field_decl
                    | method_decl;

field_decl ::= type id_list SEMI;

method_decl ::= type ID:name LPAREN param_list RPAREN block;

param_list ::= param_list COMMA type ID:name
             | type ID:name
             | /* empty */;

block ::= LBRACE block_item_list RBRACE;

block_item_list ::= block_item_list block_item
                  | /* empty */;

block_item ::= decl
             | statement;

decl ::= type id_list SEMI;

id_list ::= id_list COMMA ID:name
          | ID:name;

statement ::= assignment SEMI
            | IF LPAREN expr RPAREN block
            | WHILE LPAREN expr RPAREN block
            | FOR LPAREN assignment SEMI expr SEMI assignment RPAREN block
            | RETURN expr SEMI
            | block;

assignment ::= ID:name ASSIGN expr;

expr ::= expr:e1 PLUS expr:e2
       | expr:e1 MINUS expr:e2
       | expr:e1 TIMES expr:e2
       | expr:e1 DIVIDE expr:e2
       | expr:e1 LESS_THAN expr:e2
       | expr:e1 GREATER_THAN expr:e2
       | expr:e1 LESS_THAN_EQUALS expr:e2
       | expr:e1 GREATER_THAN_EQUALS expr:e2
       | expr:e1 EQ expr:e2
       | expr:e1 NOT_EQUALS expr:e2
       | ID:name
       | INT_LITERAL:value
       | STRING_LITERAL:value
       | CHAR_LITERAL:value
       | ID:name LPAREN arg_list RPAREN
       | TRUE
       | FALSE
       | LPAREN expr:e RPAREN;

arg_list ::= arg_list_non_empty
           | /* empty */;

arg_list_non_empty ::= arg_list_non_empty COMMA expr
                     | expr;

type ::= INT
       | VOID
       | BOOLEAN;
