package compiler.parser;

import java_cup.runtime.*;
import compiler.scanner.Scanner;
import java.io.FileReader;
import java.io.IOException;
import java.io.FileWriter;
import java.io.PrintWriter;

parser code {:
    private Scanner scanner;

    public Parser(Scanner scanner) {
        super();
        this.scanner = scanner;
    }

    public Symbol parse(String filename) throws Exception {
        try {
            scanner = new Scanner(new FileReader(filename));
            return this.parse();
        } catch (IOException e) {
            throw new RuntimeException(
                "Error al leer el archivo: " + e.getMessage()
            );
        }
    }

    @Override
    public Symbol scan() throws Exception {
        return scanner.next_token();
    }

    public void syntax_error(Symbol s) {
        String tokenValue = s.value == null ? "" : s.value.toString();
        String errorMessage = String.format(
            "Error de sintaxis en línea %d, columna %d. Token inesperado '%s'.",
            s.left + 1, s.right + 1, tokenValue
        );

        // Escribir en el archivo output.txt
        writeToFile(errorMessage);

        // Imprimir en la consola
        System.err.println(errorMessage);
    }

    private void writeToFile(String message) {
        try (PrintWriter out = new PrintWriter(
                new FileWriter("output.txt", true))) {
            out.println(message);
        } catch (IOException e) {
            System.err.println(
                "Error al escribir en el archivo: " + e.getMessage()
            );
        }
    }
:};

/* Terminales */
terminal PROGRAM,CLASS, ID, LBRACE, RBRACE, SEMI, INT, BOOLEAN, CHAR, VOID,
         IF, ELSE, FOR, WHILE, RETURN, BREAK, CONTINUE, CALLOUT,
         ASSIGN, PLUS_ASSIGN, MINUS_ASSIGN, PLUS, MINUS, TIMES, DIVIDE,
         MOD, EQ, NEQ, LT, GT, LE, GE, AND, OR, NOT, TRUE, FALSE,
         COMMA, LPAREN, RPAREN, LBRACKET, RBRACKET, INT_LITERAL,
         CHAR_LITERAL, STRING_LITERAL, NEW, UMINUS;

/* No terminales */
non terminal program, class_body_member_list, class_body_member,
             member_decl_rest, method_decl_rest, field_decl_rest,
             field_decl_continuation, id_array_rest, id_with_optional_array,
             param_list, block, var_decl_list, var_decl, id_plus_array_list,
             statement_list, statement, expr_opt, assign_op, location,
             method_call, method_name, expr_plus_list_opt, expr_plus_list,
             opt_comma_callout_arg_list, callout_arg_list, callout_arg,
             expr, assign_expr, bin_op, arith_op, rel_op, eq_op, cond_op, literal,
             int_literal, char_literal, bool_literal, type, for_init_expr,
             for_update_expr;

/* Precedencias */
precedence left OR;
precedence left AND;
precedence nonassoc EQ, NEQ;
precedence nonassoc LT, GT, LE, GE;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;
precedence right NOT;
precedence right UMINUS;

/* Símbolo inicial */
start with program;

/* Producciones */

/* Programa */
program ::= CLASS ID LBRACE class_body_member_list RBRACE;

/* Lista de miembros del cuerpo de la clase */
class_body_member_list ::= class_body_member_list class_body_member
                         | /* vacío */;

/* Miembro del cuerpo de la clase */
class_body_member ::= type id_with_optional_array member_decl_rest
                    | VOID ID method_decl_rest;

/* Resto de la declaración de miembro */
member_decl_rest ::= method_decl_rest
                   | field_decl_rest;

/* Declaración de método */
method_decl_rest ::= LPAREN param_list RPAREN block;

/* Declaración de campo */
field_decl_rest ::= field_decl_continuation SEMI;

/* Continuación de la declaración de campo */
field_decl_continuation ::= id_array_rest;

/* Resto de identificadores con arreglos (para múltiples declaraciones) */
id_array_rest ::= COMMA id_with_optional_array id_array_rest
                | /* vacío */;

/* Identificador con arreglo opcional */
id_with_optional_array ::= ID
                         | ID LBRACKET INT_LITERAL RBRACKET;

/* Lista de parámetros */
param_list ::= param_list COMMA type id_with_optional_array
             | type id_with_optional_array
             | /* vacío */;

/* Bloque de código */
block ::= LBRACE var_decl_list statement_list RBRACE;

/* Lista de declaraciones de variables locales */
var_decl_list ::= var_decl_list var_decl
                | /* vacío */;

/* Declaración de variable local */
var_decl ::= type id_plus_array_list SEMI;

/* Lista de identificadores (variables locales) con arreglos opcionales */
id_plus_array_list ::= id_plus_array_list COMMA id_with_optional_array
                     | id_with_optional_array;

/* Lista de sentencias */
statement_list ::= statement_list statement
                 | /* vacío */;

/* Sentencias */
statement ::= location assign_op expr SEMI
            | method_call SEMI
            | IF LPAREN expr RPAREN block ELSE block
            | IF LPAREN expr RPAREN block
            | WHILE LPAREN expr RPAREN block
            | FOR LPAREN for_init_expr SEMI expr_opt SEMI for_update_expr RPAREN block
            | RETURN expr_opt SEMI
            | BREAK SEMI
            | CONTINUE SEMI
            | block;

/* Expresión opcional */
expr_opt ::= expr
           | /* vacío */;

/* Inicialización del for */
for_init_expr ::= type id_with_optional_array assign_op expr
                | assign_expr
                | /* vacío */;

/* Actualización del for */
for_update_expr ::= assign_expr
                  | expr
                  | /* vacío */;

/* Expresión de asignación */
assign_expr ::= location assign_op expr;

/* Operadores de asignación */
assign_op ::= ASSIGN
            | PLUS_ASSIGN
            | MINUS_ASSIGN;

/* Ubicación (variable o arreglo) */
location ::= ID
           | ID LBRACKET expr RBRACKET;

/* Llamada a método */
method_call ::= method_name LPAREN expr_plus_list_opt RPAREN
              | CALLOUT LPAREN STRING_LITERAL opt_comma_callout_arg_list RPAREN;

/* Lista opcional de argumentos para callout */
opt_comma_callout_arg_list ::= COMMA callout_arg_list
                             | /* vacío */;

/* Nombre del método */
method_name ::= ID;

/* Lista opcional de expresiones */
expr_plus_list_opt ::= expr_plus_list
                     | /* vacío */;

/* Lista de expresiones separadas por comas */
expr_plus_list ::= expr_plus_list COMMA expr
                 | expr;

/* Lista de argumentos para callout */
callout_arg_list ::= callout_arg_list COMMA callout_arg
                   | callout_arg;

/* Argumento para callout */
callout_arg ::= expr
              | STRING_LITERAL;

/* Expresiones */
expr ::=
    location
  | method_call
  | literal
  | expr bin_op expr
  | MINUS expr %prec UMINUS
  | NOT expr
  | NEW type LBRACKET expr RBRACKET
  | LPAREN expr RPAREN;

/* Operadores binarios */
bin_op ::= arith_op
         | rel_op
         | eq_op
         | cond_op;

/* Operadores aritméticos */
arith_op ::= PLUS | MINUS | TIMES | DIVIDE | MOD;

/* Operadores relacionales */
rel_op ::= LT | GT | LE | GE;

/* Operadores de igualdad */
eq_op ::= EQ | NEQ;

/* Operadores condicionales */
cond_op ::= AND | OR;

/* Literales */
literal ::= int_literal
          | char_literal
          | bool_literal;

/* Literal entero */
int_literal ::= INT_LITERAL;

/* Literal de carácter */
char_literal ::= CHAR_LITERAL;

/* Literal booleano */
bool_literal ::= TRUE
               | FALSE;

/* Tipos de datos */
type ::= INT
       | BOOLEAN
       | CHAR;