package compiler.parser;

import java_cup.runtime.*;
import compiler.scanner.Scanner;
import java.io.FileReader;
import java.io.IOException;
import java.io.FileWriter;
import java.io.PrintWriter;

parser code {:
    private Scanner scanner;

    public Parser(Scanner scanner) {
        super();
        this.scanner = scanner;
    }

    public Symbol parse(String filename) throws Exception {
        try {
            scanner = new Scanner(new FileReader(filename));
            return this.parse();
        } catch (IOException e) {
            throw new RuntimeException("Error al leer el archivo: " + e.getMessage());
        }
    }

    @Override
    public Symbol scan() throws Exception {
        return scanner.next_token();
    }

    public void syntax_error(Symbol s) {
        String tokenName = sym.terminalNames[s.sym];
        String tokenValue = s.value == null ? "" : s.value.toString();
        String errorMessage = String.format(
        "Se encontró un error de sintaxis en la línea %d en la Columna %d Token inesperado '%s'.",
            s.left, s.right, tokenValue, tokenName
        );

        // Escribir en el archivo output.txt
        writeToFile(errorMessage);

        // Imprimir en la consola
        System.err.println(errorMessage);
    }

    private void writeToFile(String message) {
        try (PrintWriter out = new PrintWriter(new FileWriter("output.txt", true))) {
            out.println(message);
        } catch (IOException e) {
            System.err.println("Error al escribir en el archivo de salida: " + e.getMessage());
        }
    }
:};

/* Terminals (tokens retornados por el scanner) */
terminal CLASS, INT, VOID, BOOLEAN, CHAR, TRUE, FALSE, IF, ELSE, RETURN, WHILE, FOR, NEW, BREAK, CONTINUE, CALLOUT;
terminal ASSIGN, EQ, NOT_EQUALS, SEMI, LBRACE, RBRACE, LPAREN, RPAREN, PLUS, MINUS, TIMES, DIVIDE, COMMA;
terminal LESS_THAN, GREATER_THAN, LESS_THAN_EQUALS, GREATER_THAN_EQUALS, AND, OR, MOD, LBRACKET, RBRACKET;
terminal PLUS_ASSIGN, MINUS_ASSIGN, TIMES_ASSIGN, DIVIDE_ASSIGN;
terminal String ID;
terminal Integer INT_LITERAL, HEX_LITERAL;
terminal String STRING_LITERAL, CHAR_LITERAL;

/* Non-terminals */
non terminal program, class_decl, method_decl, type;
non terminal statement, expr, param_list, arg_list;
non terminal class_body_member_list, class_body_member, field_decl, block;
non terminal block_item_list, block_item, decl, id_list, assignment;
non terminal for_init, for_update, decl_assign;
non terminal arg_list_non_empty, if_statement, array_access;

/* Precedencias */
precedence left OR;
precedence left AND;
precedence left EQ, NOT_EQUALS;
precedence left LESS_THAN, GREATER_THAN, LESS_THAN_EQUALS, GREATER_THAN_EQUALS;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;
precedence right ASSIGN;

/* La gramática */
start with program;

program ::= class_decl;

class_decl ::= CLASS ID LBRACE class_body_member_list RBRACE;

class_body_member_list ::= class_body_member_list class_body_member
                         | /* empty */;

class_body_member ::= field_decl
                    | method_decl;

field_decl ::= type id_list SEMI
             | type LBRACKET INT_LITERAL RBRACKET ID SEMI; /* Manejo de arreglos */

method_decl ::= type ID LPAREN param_list RPAREN block;

param_list ::= param_list COMMA type ID
             | type ID
             | /* empty */;

block ::= LBRACE block_item_list RBRACE;

block_item_list ::= block_item_list block_item
                  | /* empty */;

block_item ::= decl
             | statement;

decl ::= type id_list SEMI
       | type id_list ASSIGN expr SEMI; 

decl_assign ::= type ID ASSIGN expr;

id_list ::= id_list COMMA ID
          | ID;

statement ::= assignment SEMI
            | if_statement
            | WHILE LPAREN expr RPAREN block
            | FOR LPAREN for_init SEMI expr SEMI for_update RPAREN block
            | RETURN expr SEMI
            | BREAK SEMI
            | CONTINUE SEMI
            | expr SEMI        
            | block;

if_statement ::= IF LPAREN expr RPAREN block
              | IF LPAREN expr RPAREN block ELSE block;

assignment ::= array_access ASSIGN expr  
             | ID ASSIGN expr
             | ID PLUS_ASSIGN expr
             | ID MINUS_ASSIGN expr
             | ID TIMES_ASSIGN expr
             | ID DIVIDE_ASSIGN expr;

array_access ::= ID LBRACKET expr RBRACKET;  /* Definición del acceso a elementos de arreglos */

expr ::= expr PLUS expr
       | expr MINUS expr
       | expr TIMES expr
       | expr DIVIDE expr
       | expr MOD expr
       | expr LESS_THAN expr
       | expr GREATER_THAN expr
       | expr LESS_THAN_EQUALS expr
       | expr GREATER_THAN_EQUALS expr
       | expr EQ expr
       | expr NOT_EQUALS expr
       | expr AND expr
       | expr OR expr
       | array_access                   /* Incluir el acceso al arreglo en las expresiones */
       | NEW type LBRACKET expr RBRACKET  /* Creación de arreglos */
       | ID
       | INT_LITERAL
       | HEX_LITERAL
       | STRING_LITERAL
       | CHAR_LITERAL
       | ID LPAREN arg_list RPAREN
       | CALLOUT LPAREN STRING_LITERAL COMMA arg_list RPAREN
       | TRUE
       | FALSE
       | LPAREN expr RPAREN;

for_init ::= decl_assign /* Cambiar aquí para que sólo acepte decl_assign o asignaciones directamente */
           | assignment;

for_update ::= assignment;

arg_list ::= arg_list_non_empty
           | /* empty */;

arg_list_non_empty ::= arg_list_non_empty COMMA expr
                     | expr;

type ::= INT
       | VOID
       | BOOLEAN
       | CHAR;  
